.model small
.stack 100h
.data
MSG DB 0DH,0AH,'Illigal character found',0ah,0dh,'$'
MSG1 DB 0DH,0AH,'Sorted Array:- $'
MSG2 DB 'Enter Input Array : $'
A DW 16 dup (?)
COUNT DW 0
MAX DW 16
COUNT1 DW 0
.code
main proc
mov ax,@data
mov ds,ax

LEA SI,A
PUSH SI

lea dx,msg2
mov ah,9
int 21h

mov ax,0

START:

MOV BX,0    ;TOTAL
MOV CX,0    ;SIGN
MOV DX,0

MOV AH,1
INT 21H
    

CMP AL,'x'
JE SORT
PUSH DX
MOV DX,COUNT     ; CHECKING INTEGER COUNTER IS EQUAL TO MAX OR NOT 
CMP DX,MAX
POP DX
JE SORT

CMP AL,'-'       ; FOR NEGATIVE INTEGER
JE MINUS
MOV CX,0
CMP AL,'+'
JE PLUS
JMP REPEAT

MINUS:

MOV CX,1         ; IF THE INTEGER IS NEGATIVE
       
PLUS:

INT 21H

REPEAT:

CMP AL,'0'
JNGE NOT_DIGIT_CHECK    ; ILLIGAL DIGIT CHECK
CMP AL,'9'
JNLE NOT_DIGIT
JMP SKIP

NOT_DIGIT_CHECK:      
CMP AL,' '            
JE END
JMP NOT_DIGIT

SKIP:

AND AX,000FH          ; CONVERTING TO INTEGER
PUSH AX
MOV AX,10             ; AX = AX*BX (FOR 16 BIT)
MUL BX
POP BX
ADD BX,AX             ; BX = 10*BX + AX

MOV AH,1
INT 21H
JMP REPEAT


END:

CMP CX,0              ;CHECKING NEGATIVE OR NOT
JE A_INSERT
NEG BX

A_INSERT:             ; INSERT TO ARRAY
MOV [SI],BX           
ADD SI,2
INC COUNT
JMP START

              

NOT_DIGIT:
lea dx,MSG
MOV AH,9
INT 21H

JMP ENDMAIN:

SORT: 
                     ; POPPING ARRAY'S STARTING POSITION 
POP SI
    
mov BX,COUNT         ;ARRAY LENGTH 

MOV DI,SI
mov cx,COUNT         ;COUNTER FOR HEAPIFY
shr cx,1             ;CX = LENGTH/2
jcxz ENDF
heapcall:
SUB CX,1             ;CX = (LENGTH/2)-1 EXECUTE LOOP CX TIMES 
call heapify
ADD CX,1
loop heapcall


MOV CX,BX            ; EXECUTE LOOP ARRAY LENGTHS TIME 
MAXHEAP:
PUSH CX
DEC CX
MOV BX,CX            ; SWAPING FIRST(MAX) AND LAST
MOV CX,0
MOV AX,BX
CALL SWAP
CALL heapify
pop cx
loop MAXHEAP






ENDF:
MOV CX,COUNT        ; NUMBER OF INTEGER ASSIGN

lea dx,msg1
mov ah,9
int 21h

JCXZ ENDMAIN        ; CHECKNG IF INTEGER NUMBER IS ZERO OR NOT
PRINT:

MOV AX,[SI]         ; ASSIGNING FIRST INTEGER TO AX
ADD SI,2

cmp ax,0
JGE ENDIF           ; CHEKING POSITIVE OR NEGATIVE INTEGER
PUSH AX 
MOV DL,'-'
MOV AH,2
INT 21H
POP AX
NEG AX

ENDIF:

MOV COUNT1,0       ; FOR DIGIT COUNT
MOV BX,10D

REPEAT1:

XOR DX,DX          ;
DIV BX
PUSH DX
INC COUNT1

OR AX,AX           ; CHECKING QUOTIENT IS ZERO OR NOT
JNE REPEAT1

MOV AH,2
XCHG CX,COUNT1
PRINT_LOOP:
POP DX             ; DX = REMAINDER
add DL,30H         
INT 21H
LOOP PRINT_LOOP
MOV CX,COUNT1

MOV DL,' '
INT 21H

LOOP PRINT

ENDMAIN:

mov ah,4ch
int 21h    
main endp


heapify proc
PUSH CX         ; CX = PARENT 
H_LOOP:         ; BX = ARRAY LENGTH
PUSH CX         


MOV AX,CX       ; AX = LARGEST INTEGER    
;MOV CX,CX
SHL CX,1
MOV DX,CX
ADD DX,2
ADD CX,1        ; CX = LEFT CHILD ;DX = RIGHT CHILD 
                ; CX = 2*PARENT VALUE+1 
                ; DX = 2*PARENT VALUE+2

CMP CX,BX       ; CHECKING CX IS OUT OF ARRAY LENGTH 
JGE SECONDCHECK             
PUSH AX
PUSH CX         ; COMPARING LEFTCHILD WITH PARENT
SHL AX,1
SHL CX,1
PUSH SI
PUSH DI
ADD SI,AX
ADD DI,CX

PUSH DX
MOV DX,[SI]
CMP [DI],DX
POP DX
POP DI
POP SI
POP CX
POP AX
JLE SECONDCHECK
MOV AX,CX       ; SET LEFT CHILD AS LARGEST



SECONDCHECK:
CMP DX,BX       ; CHECKING CX IS OUT OF ARRAY LENGTH
JGE LASTCHECK
PUSH AX
PUSH DX
SHL AX,1
SHL DX,1        ; COMPARING LEFTCHILD WITH PARENT
PUSH SI
PUSH DI
ADD SI,AX
ADD DI,DX

PUSH DX
MOV DX,[SI]
CMP [DI],DX
POP DX
POP DI
POP SI
POP DX
POP AX           ; SET LEFT CHILD AS LARGEST
JLE LASTCHECK
MOV AX,DX


LASTCHECK:
POP CX            
CMP CX,AX        ; CHECK PARENT IS LAEGEST OR NOT
JE BREAK
CALL SWAP        ; SWAPPING LARGEST AND PARENT
MOV CX,AX
JMP H_LOOP

BREAK:
POP CX
ret    
heapify endp


SWAP PROC

PUSH AX
PUSH CX
SHL AX,1      ;for word
SHL CX,1
PUSH SI
PUSH DI
ADD SI,AX
ADD DI,CX
MOV AX,[SI]
XCHG AX,[DI]
MOV [SI],AX
POP DI
POP SI
POP CX
POP AX
RET

SWAP ENDP